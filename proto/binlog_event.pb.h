// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: binlog_event.proto

#ifndef PROTOBUF_binlog_5fevent_2eproto__INCLUDED
#define PROTOBUF_binlog_5fevent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace binlog_listener {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_binlog_5fevent_2eproto();
void protobuf_AssignDesc_binlog_5fevent_2eproto();
void protobuf_ShutdownFile_binlog_5fevent_2eproto();

class Field;
class Row;
class MysubStatus;
class BinlogEvent;

enum MysqlType {
  MYSQL_TYPE_DECIMAL = 0,
  MYSQL_TYPE_TINY = 1,
  MYSQL_TYPE_SHORT = 2,
  MYSQL_TYPE_LONG = 3,
  MYSQL_TYPE_FLOAT = 4,
  MYSQL_TYPE_DOUBLE = 5,
  MYSQL_TYPE_NULL = 6,
  MYSQL_TYPE_TIMESTAMP = 7,
  MYSQL_TYPE_LONGLONG = 8,
  MYSQL_TYPE_INT24 = 9,
  MYSQL_TYPE_DATE = 10,
  MYSQL_TYPE_TIME = 11,
  MYSQL_TYPE_DATETIME = 12,
  MYSQL_TYPE_YEAR = 13,
  MYSQL_TYPE_NEWDATE = 14,
  MYSQL_TYPE_VARCHAR = 15,
  MYSQL_TYPE_BIT = 16,
  MYSQL_TYPE_NEWDECIMAL = 246,
  MYSQL_TYPE_ENUM = 247,
  MYSQL_TYPE_SET = 248,
  MYSQL_TYPE_TINY_BLOB = 249,
  MYSQL_TYPE_MEDIUM_BLOB = 250,
  MYSQL_TYPE_LONG_BLOB = 251,
  MYSQL_TYPE_BLOB = 252,
  MYSQL_TYPE_VAR_STRING = 253,
  MYSQL_TYPE_STRING = 254,
  MYSQL_TYPE_GEOMETRY = 255
};
bool MysqlType_IsValid(int value);
const MysqlType MysqlType_MIN = MYSQL_TYPE_DECIMAL;
const MysqlType MysqlType_MAX = MYSQL_TYPE_GEOMETRY;
const int MysqlType_ARRAYSIZE = MysqlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MysqlType_descriptor();
inline const ::std::string& MysqlType_Name(MysqlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MysqlType_descriptor(), value);
}
inline bool MysqlType_Parse(
    const ::std::string& name, MysqlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MysqlType>(
    MysqlType_descriptor(), name, value);
}
enum EventType {
  UPDATE_EVENT = 0,
  INSERT_EVENT = 1,
  DELETE_EVENT = 2
};
bool EventType_IsValid(int value);
const EventType EventType_MIN = UPDATE_EVENT;
const EventType EventType_MAX = DELETE_EVENT;
const int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventType_descriptor();
inline const ::std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventType_descriptor(), value);
}
inline bool EventType_Parse(
    const ::std::string& name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
// ===================================================================

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();
  
  Field(const Field& from);
  
  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();
  
  void Swap(Field* other);
  
  // implements Message ----------------------------------------------
  
  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required .binlog_listener.MysqlType mysql_type = 2;
  inline bool has_mysql_type() const;
  inline void clear_mysql_type();
  static const int kMysqlTypeFieldNumber = 2;
  inline binlog_listener::MysqlType mysql_type() const;
  inline void set_mysql_type(binlog_listener::MysqlType value);
  
  // required bool is_signed = 3 [default = false];
  inline bool has_is_signed() const;
  inline void clear_is_signed();
  static const int kIsSignedFieldNumber = 3;
  inline bool is_signed() const;
  inline void set_is_signed(bool value);
  
  // required bool is_pk = 4;
  inline bool has_is_pk() const;
  inline void clear_is_pk();
  static const int kIsPkFieldNumber = 4;
  inline bool is_pk() const;
  inline void set_is_pk(bool value);
  
  // optional bytes old_value = 5;
  inline bool has_old_value() const;
  inline void clear_old_value();
  static const int kOldValueFieldNumber = 5;
  inline const ::std::string& old_value() const;
  inline void set_old_value(const ::std::string& value);
  inline void set_old_value(const char* value);
  inline void set_old_value(const void* value, size_t size);
  inline ::std::string* mutable_old_value();
  inline ::std::string* release_old_value();
  
  // optional bytes is_old_null = 6;
  inline bool has_is_old_null() const;
  inline void clear_is_old_null();
  static const int kIsOldNullFieldNumber = 6;
  inline const ::std::string& is_old_null() const;
  inline void set_is_old_null(const ::std::string& value);
  inline void set_is_old_null(const char* value);
  inline void set_is_old_null(const void* value, size_t size);
  inline ::std::string* mutable_is_old_null();
  inline ::std::string* release_is_old_null();
  
  // optional bytes new_value = 7;
  inline bool has_new_value() const;
  inline void clear_new_value();
  static const int kNewValueFieldNumber = 7;
  inline const ::std::string& new_value() const;
  inline void set_new_value(const ::std::string& value);
  inline void set_new_value(const char* value);
  inline void set_new_value(const void* value, size_t size);
  inline ::std::string* mutable_new_value();
  inline ::std::string* release_new_value();
  
  // optional bytes is_new_null = 8;
  inline bool has_is_new_null() const;
  inline void clear_is_new_null();
  static const int kIsNewNullFieldNumber = 8;
  inline const ::std::string& is_new_null() const;
  inline void set_is_new_null(const ::std::string& value);
  inline void set_is_new_null(const char* value);
  inline void set_is_new_null(const void* value, size_t size);
  inline ::std::string* mutable_is_new_null();
  inline ::std::string* release_is_new_null();
  
  // optional string charset = 9;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 9;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const char* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  
  // @@protoc_insertion_point(class_scope:binlog_listener.Field)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mysql_type();
  inline void clear_has_mysql_type();
  inline void set_has_is_signed();
  inline void clear_has_is_signed();
  inline void set_has_is_pk();
  inline void clear_has_is_pk();
  inline void set_has_old_value();
  inline void clear_has_old_value();
  inline void set_has_is_old_null();
  inline void clear_has_is_old_null();
  inline void set_has_new_value();
  inline void clear_has_new_value();
  inline void set_has_is_new_null();
  inline void clear_has_is_new_null();
  inline void set_has_charset();
  inline void clear_has_charset();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  int mysql_type_;
  bool is_signed_;
  bool is_pk_;
  ::std::string* old_value_;
  ::std::string* is_old_null_;
  ::std::string* new_value_;
  ::std::string* is_new_null_;
  ::std::string* charset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_binlog_5fevent_2eproto();
  friend void protobuf_AssignDesc_binlog_5fevent_2eproto();
  friend void protobuf_ShutdownFile_binlog_5fevent_2eproto();
  
  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Row : public ::google::protobuf::Message {
 public:
  Row();
  virtual ~Row();
  
  Row(const Row& from);
  
  inline Row& operator=(const Row& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Row& default_instance();
  
  void Swap(Row* other);
  
  // implements Message ----------------------------------------------
  
  Row* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Row& from);
  void MergeFrom(const Row& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .binlog_listener.Field field = 1;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 1;
  inline const ::binlog_listener::Field& field(int index) const;
  inline ::binlog_listener::Field* mutable_field(int index);
  inline ::binlog_listener::Field* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::binlog_listener::Field >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::binlog_listener::Field >*
      mutable_field();
  
  // @@protoc_insertion_point(class_scope:binlog_listener.Row)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::binlog_listener::Field > field_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_binlog_5fevent_2eproto();
  friend void protobuf_AssignDesc_binlog_5fevent_2eproto();
  friend void protobuf_ShutdownFile_binlog_5fevent_2eproto();
  
  void InitAsDefaultInstance();
  static Row* default_instance_;
};
// -------------------------------------------------------------------

class MysubStatus : public ::google::protobuf::Message {
 public:
  MysubStatus();
  virtual ~MysubStatus();
  
  MysubStatus(const MysubStatus& from);
  
  inline MysubStatus& operator=(const MysubStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MysubStatus& default_instance();
  
  void Swap(MysubStatus* other);
  
  // implements Message ----------------------------------------------
  
  MysubStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MysubStatus& from);
  void MergeFrom(const MysubStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string log_file = 1;
  inline bool has_log_file() const;
  inline void clear_log_file();
  static const int kLogFileFieldNumber = 1;
  inline const ::std::string& log_file() const;
  inline void set_log_file(const ::std::string& value);
  inline void set_log_file(const char* value);
  inline void set_log_file(const char* value, size_t size);
  inline ::std::string* mutable_log_file();
  inline ::std::string* release_log_file();
  
  // required uint32 offset = 2;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 2;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);
  
  // required uint32 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // required uint32 safe_offset = 4;
  inline bool has_safe_offset() const;
  inline void clear_safe_offset();
  static const int kSafeOffsetFieldNumber = 4;
  inline ::google::protobuf::uint32 safe_offset() const;
  inline void set_safe_offset(::google::protobuf::uint32 value);
  
  // required uint32 safe_timestamp = 5;
  inline bool has_safe_timestamp() const;
  inline void clear_safe_timestamp();
  static const int kSafeTimestampFieldNumber = 5;
  inline ::google::protobuf::uint32 safe_timestamp() const;
  inline void set_safe_timestamp(::google::protobuf::uint32 value);
  
  // required string host = 6;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 6;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  
  // required uint32 port = 7;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 7;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // optional uint64 progress = 8;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 8;
  inline ::google::protobuf::uint64 progress() const;
  inline void set_progress(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:binlog_listener.MysubStatus)
 private:
  inline void set_has_log_file();
  inline void clear_has_log_file();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_safe_offset();
  inline void clear_has_safe_offset();
  inline void set_has_safe_timestamp();
  inline void clear_has_safe_timestamp();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_progress();
  inline void clear_has_progress();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* log_file_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::uint32 safe_offset_;
  ::google::protobuf::uint32 safe_timestamp_;
  ::std::string* host_;
  ::google::protobuf::uint64 progress_;
  ::google::protobuf::uint32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_binlog_5fevent_2eproto();
  friend void protobuf_AssignDesc_binlog_5fevent_2eproto();
  friend void protobuf_ShutdownFile_binlog_5fevent_2eproto();
  
  void InitAsDefaultInstance();
  static MysubStatus* default_instance_;
};
// -------------------------------------------------------------------

class BinlogEvent : public ::google::protobuf::Message {
 public:
  BinlogEvent();
  virtual ~BinlogEvent();
  
  BinlogEvent(const BinlogEvent& from);
  
  inline BinlogEvent& operator=(const BinlogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinlogEvent& default_instance();
  
  void Swap(BinlogEvent* other);
  
  // implements Message ----------------------------------------------
  
  BinlogEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BinlogEvent& from);
  void MergeFrom(const BinlogEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string db = 1;
  inline bool has_db() const;
  inline void clear_db();
  static const int kDbFieldNumber = 1;
  inline const ::std::string& db() const;
  inline void set_db(const ::std::string& value);
  inline void set_db(const char* value);
  inline void set_db(const char* value, size_t size);
  inline ::std::string* mutable_db();
  inline ::std::string* release_db();
  
  // required string table = 2;
  inline bool has_table() const;
  inline void clear_table();
  static const int kTableFieldNumber = 2;
  inline const ::std::string& table() const;
  inline void set_table(const ::std::string& value);
  inline void set_table(const char* value);
  inline void set_table(const char* value, size_t size);
  inline ::std::string* mutable_table();
  inline ::std::string* release_table();
  
  // required .binlog_listener.EventType event_type = 3;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 3;
  inline binlog_listener::EventType event_type() const;
  inline void set_event_type(binlog_listener::EventType value);
  
  // optional .binlog_listener.MysubStatus mysub_status = 4;
  inline bool has_mysub_status() const;
  inline void clear_mysub_status();
  static const int kMysubStatusFieldNumber = 4;
  inline const ::binlog_listener::MysubStatus& mysub_status() const;
  inline ::binlog_listener::MysubStatus* mutable_mysub_status();
  inline ::binlog_listener::MysubStatus* release_mysub_status();
  
  // optional string charset = 5;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 5;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const char* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  
  // optional .binlog_listener.Row row = 6;
  inline bool has_row() const;
  inline void clear_row();
  static const int kRowFieldNumber = 6;
  inline const ::binlog_listener::Row& row() const;
  inline ::binlog_listener::Row* mutable_row();
  inline ::binlog_listener::Row* release_row();
  
  // @@protoc_insertion_point(class_scope:binlog_listener.BinlogEvent)
 private:
  inline void set_has_db();
  inline void clear_has_db();
  inline void set_has_table();
  inline void clear_has_table();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_mysub_status();
  inline void clear_has_mysub_status();
  inline void set_has_charset();
  inline void clear_has_charset();
  inline void set_has_row();
  inline void clear_has_row();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* db_;
  ::std::string* table_;
  ::binlog_listener::MysubStatus* mysub_status_;
  ::std::string* charset_;
  ::binlog_listener::Row* row_;
  int event_type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_binlog_5fevent_2eproto();
  friend void protobuf_AssignDesc_binlog_5fevent_2eproto();
  friend void protobuf_ShutdownFile_binlog_5fevent_2eproto();
  
  void InitAsDefaultInstance();
  static BinlogEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// Field

// required string name = 1;
inline bool Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Field::name() const {
  return *name_;
}
inline void Field::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Field::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .binlog_listener.MysqlType mysql_type = 2;
inline bool Field::has_mysql_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Field::set_has_mysql_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Field::clear_has_mysql_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Field::clear_mysql_type() {
  mysql_type_ = 0;
  clear_has_mysql_type();
}
inline binlog_listener::MysqlType Field::mysql_type() const {
  return static_cast< binlog_listener::MysqlType >(mysql_type_);
}
inline void Field::set_mysql_type(binlog_listener::MysqlType value) {
  GOOGLE_DCHECK(binlog_listener::MysqlType_IsValid(value));
  set_has_mysql_type();
  mysql_type_ = value;
}

// required bool is_signed = 3 [default = false];
inline bool Field::has_is_signed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::set_has_is_signed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Field::clear_has_is_signed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Field::clear_is_signed() {
  is_signed_ = false;
  clear_has_is_signed();
}
inline bool Field::is_signed() const {
  return is_signed_;
}
inline void Field::set_is_signed(bool value) {
  set_has_is_signed();
  is_signed_ = value;
}

// required bool is_pk = 4;
inline bool Field::has_is_pk() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Field::set_has_is_pk() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Field::clear_has_is_pk() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Field::clear_is_pk() {
  is_pk_ = false;
  clear_has_is_pk();
}
inline bool Field::is_pk() const {
  return is_pk_;
}
inline void Field::set_is_pk(bool value) {
  set_has_is_pk();
  is_pk_ = value;
}

// optional bytes old_value = 5;
inline bool Field::has_old_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Field::set_has_old_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Field::clear_has_old_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Field::clear_old_value() {
  if (old_value_ != &::google::protobuf::internal::kEmptyString) {
    old_value_->clear();
  }
  clear_has_old_value();
}
inline const ::std::string& Field::old_value() const {
  return *old_value_;
}
inline void Field::set_old_value(const ::std::string& value) {
  set_has_old_value();
  if (old_value_ == &::google::protobuf::internal::kEmptyString) {
    old_value_ = new ::std::string;
  }
  old_value_->assign(value);
}
inline void Field::set_old_value(const char* value) {
  set_has_old_value();
  if (old_value_ == &::google::protobuf::internal::kEmptyString) {
    old_value_ = new ::std::string;
  }
  old_value_->assign(value);
}
inline void Field::set_old_value(const void* value, size_t size) {
  set_has_old_value();
  if (old_value_ == &::google::protobuf::internal::kEmptyString) {
    old_value_ = new ::std::string;
  }
  old_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_old_value() {
  set_has_old_value();
  if (old_value_ == &::google::protobuf::internal::kEmptyString) {
    old_value_ = new ::std::string;
  }
  return old_value_;
}
inline ::std::string* Field::release_old_value() {
  clear_has_old_value();
  if (old_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_value_;
    old_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes is_old_null = 6;
inline bool Field::has_is_old_null() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Field::set_has_is_old_null() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Field::clear_has_is_old_null() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Field::clear_is_old_null() {
  if (is_old_null_ != &::google::protobuf::internal::kEmptyString) {
    is_old_null_->clear();
  }
  clear_has_is_old_null();
}
inline const ::std::string& Field::is_old_null() const {
  return *is_old_null_;
}
inline void Field::set_is_old_null(const ::std::string& value) {
  set_has_is_old_null();
  if (is_old_null_ == &::google::protobuf::internal::kEmptyString) {
    is_old_null_ = new ::std::string;
  }
  is_old_null_->assign(value);
}
inline void Field::set_is_old_null(const char* value) {
  set_has_is_old_null();
  if (is_old_null_ == &::google::protobuf::internal::kEmptyString) {
    is_old_null_ = new ::std::string;
  }
  is_old_null_->assign(value);
}
inline void Field::set_is_old_null(const void* value, size_t size) {
  set_has_is_old_null();
  if (is_old_null_ == &::google::protobuf::internal::kEmptyString) {
    is_old_null_ = new ::std::string;
  }
  is_old_null_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_is_old_null() {
  set_has_is_old_null();
  if (is_old_null_ == &::google::protobuf::internal::kEmptyString) {
    is_old_null_ = new ::std::string;
  }
  return is_old_null_;
}
inline ::std::string* Field::release_is_old_null() {
  clear_has_is_old_null();
  if (is_old_null_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_old_null_;
    is_old_null_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes new_value = 7;
inline bool Field::has_new_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Field::set_has_new_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Field::clear_has_new_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Field::clear_new_value() {
  if (new_value_ != &::google::protobuf::internal::kEmptyString) {
    new_value_->clear();
  }
  clear_has_new_value();
}
inline const ::std::string& Field::new_value() const {
  return *new_value_;
}
inline void Field::set_new_value(const ::std::string& value) {
  set_has_new_value();
  if (new_value_ == &::google::protobuf::internal::kEmptyString) {
    new_value_ = new ::std::string;
  }
  new_value_->assign(value);
}
inline void Field::set_new_value(const char* value) {
  set_has_new_value();
  if (new_value_ == &::google::protobuf::internal::kEmptyString) {
    new_value_ = new ::std::string;
  }
  new_value_->assign(value);
}
inline void Field::set_new_value(const void* value, size_t size) {
  set_has_new_value();
  if (new_value_ == &::google::protobuf::internal::kEmptyString) {
    new_value_ = new ::std::string;
  }
  new_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_new_value() {
  set_has_new_value();
  if (new_value_ == &::google::protobuf::internal::kEmptyString) {
    new_value_ = new ::std::string;
  }
  return new_value_;
}
inline ::std::string* Field::release_new_value() {
  clear_has_new_value();
  if (new_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = new_value_;
    new_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes is_new_null = 8;
inline bool Field::has_is_new_null() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Field::set_has_is_new_null() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Field::clear_has_is_new_null() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Field::clear_is_new_null() {
  if (is_new_null_ != &::google::protobuf::internal::kEmptyString) {
    is_new_null_->clear();
  }
  clear_has_is_new_null();
}
inline const ::std::string& Field::is_new_null() const {
  return *is_new_null_;
}
inline void Field::set_is_new_null(const ::std::string& value) {
  set_has_is_new_null();
  if (is_new_null_ == &::google::protobuf::internal::kEmptyString) {
    is_new_null_ = new ::std::string;
  }
  is_new_null_->assign(value);
}
inline void Field::set_is_new_null(const char* value) {
  set_has_is_new_null();
  if (is_new_null_ == &::google::protobuf::internal::kEmptyString) {
    is_new_null_ = new ::std::string;
  }
  is_new_null_->assign(value);
}
inline void Field::set_is_new_null(const void* value, size_t size) {
  set_has_is_new_null();
  if (is_new_null_ == &::google::protobuf::internal::kEmptyString) {
    is_new_null_ = new ::std::string;
  }
  is_new_null_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_is_new_null() {
  set_has_is_new_null();
  if (is_new_null_ == &::google::protobuf::internal::kEmptyString) {
    is_new_null_ = new ::std::string;
  }
  return is_new_null_;
}
inline ::std::string* Field::release_is_new_null() {
  clear_has_is_new_null();
  if (is_new_null_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = is_new_null_;
    is_new_null_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string charset = 9;
inline bool Field::has_charset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Field::set_has_charset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Field::clear_has_charset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Field::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& Field::charset() const {
  return *charset_;
}
inline void Field::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void Field::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void Field::set_charset(const char* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* Field::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Row

// repeated .binlog_listener.Field field = 1;
inline int Row::field_size() const {
  return field_.size();
}
inline void Row::clear_field() {
  field_.Clear();
}
inline const ::binlog_listener::Field& Row::field(int index) const {
  return field_.Get(index);
}
inline ::binlog_listener::Field* Row::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::binlog_listener::Field* Row::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::binlog_listener::Field >&
Row::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::binlog_listener::Field >*
Row::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// MysubStatus

// required string log_file = 1;
inline bool MysubStatus::has_log_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MysubStatus::set_has_log_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MysubStatus::clear_has_log_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MysubStatus::clear_log_file() {
  if (log_file_ != &::google::protobuf::internal::kEmptyString) {
    log_file_->clear();
  }
  clear_has_log_file();
}
inline const ::std::string& MysubStatus::log_file() const {
  return *log_file_;
}
inline void MysubStatus::set_log_file(const ::std::string& value) {
  set_has_log_file();
  if (log_file_ == &::google::protobuf::internal::kEmptyString) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(value);
}
inline void MysubStatus::set_log_file(const char* value) {
  set_has_log_file();
  if (log_file_ == &::google::protobuf::internal::kEmptyString) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(value);
}
inline void MysubStatus::set_log_file(const char* value, size_t size) {
  set_has_log_file();
  if (log_file_ == &::google::protobuf::internal::kEmptyString) {
    log_file_ = new ::std::string;
  }
  log_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MysubStatus::mutable_log_file() {
  set_has_log_file();
  if (log_file_ == &::google::protobuf::internal::kEmptyString) {
    log_file_ = new ::std::string;
  }
  return log_file_;
}
inline ::std::string* MysubStatus::release_log_file() {
  clear_has_log_file();
  if (log_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = log_file_;
    log_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 offset = 2;
inline bool MysubStatus::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MysubStatus::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MysubStatus::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MysubStatus::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 MysubStatus::offset() const {
  return offset_;
}
inline void MysubStatus::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required uint32 timestamp = 3;
inline bool MysubStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MysubStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MysubStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MysubStatus::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 MysubStatus::timestamp() const {
  return timestamp_;
}
inline void MysubStatus::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required uint32 safe_offset = 4;
inline bool MysubStatus::has_safe_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MysubStatus::set_has_safe_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MysubStatus::clear_has_safe_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MysubStatus::clear_safe_offset() {
  safe_offset_ = 0u;
  clear_has_safe_offset();
}
inline ::google::protobuf::uint32 MysubStatus::safe_offset() const {
  return safe_offset_;
}
inline void MysubStatus::set_safe_offset(::google::protobuf::uint32 value) {
  set_has_safe_offset();
  safe_offset_ = value;
}

// required uint32 safe_timestamp = 5;
inline bool MysubStatus::has_safe_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MysubStatus::set_has_safe_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MysubStatus::clear_has_safe_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MysubStatus::clear_safe_timestamp() {
  safe_timestamp_ = 0u;
  clear_has_safe_timestamp();
}
inline ::google::protobuf::uint32 MysubStatus::safe_timestamp() const {
  return safe_timestamp_;
}
inline void MysubStatus::set_safe_timestamp(::google::protobuf::uint32 value) {
  set_has_safe_timestamp();
  safe_timestamp_ = value;
}

// required string host = 6;
inline bool MysubStatus::has_host() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MysubStatus::set_has_host() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MysubStatus::clear_has_host() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MysubStatus::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& MysubStatus::host() const {
  return *host_;
}
inline void MysubStatus::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void MysubStatus::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void MysubStatus::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MysubStatus::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* MysubStatus::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 port = 7;
inline bool MysubStatus::has_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MysubStatus::set_has_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MysubStatus::clear_has_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MysubStatus::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 MysubStatus::port() const {
  return port_;
}
inline void MysubStatus::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// optional uint64 progress = 8;
inline bool MysubStatus::has_progress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MysubStatus::set_has_progress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MysubStatus::clear_has_progress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MysubStatus::clear_progress() {
  progress_ = GOOGLE_ULONGLONG(0);
  clear_has_progress();
}
inline ::google::protobuf::uint64 MysubStatus::progress() const {
  return progress_;
}
inline void MysubStatus::set_progress(::google::protobuf::uint64 value) {
  set_has_progress();
  progress_ = value;
}

// -------------------------------------------------------------------

// BinlogEvent

// required string db = 1;
inline bool BinlogEvent::has_db() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinlogEvent::set_has_db() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BinlogEvent::clear_has_db() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BinlogEvent::clear_db() {
  if (db_ != &::google::protobuf::internal::kEmptyString) {
    db_->clear();
  }
  clear_has_db();
}
inline const ::std::string& BinlogEvent::db() const {
  return *db_;
}
inline void BinlogEvent::set_db(const ::std::string& value) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::kEmptyString) {
    db_ = new ::std::string;
  }
  db_->assign(value);
}
inline void BinlogEvent::set_db(const char* value) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::kEmptyString) {
    db_ = new ::std::string;
  }
  db_->assign(value);
}
inline void BinlogEvent::set_db(const char* value, size_t size) {
  set_has_db();
  if (db_ == &::google::protobuf::internal::kEmptyString) {
    db_ = new ::std::string;
  }
  db_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BinlogEvent::mutable_db() {
  set_has_db();
  if (db_ == &::google::protobuf::internal::kEmptyString) {
    db_ = new ::std::string;
  }
  return db_;
}
inline ::std::string* BinlogEvent::release_db() {
  clear_has_db();
  if (db_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = db_;
    db_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string table = 2;
inline bool BinlogEvent::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BinlogEvent::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BinlogEvent::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BinlogEvent::clear_table() {
  if (table_ != &::google::protobuf::internal::kEmptyString) {
    table_->clear();
  }
  clear_has_table();
}
inline const ::std::string& BinlogEvent::table() const {
  return *table_;
}
inline void BinlogEvent::set_table(const ::std::string& value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(value);
}
inline void BinlogEvent::set_table(const char* value) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(value);
}
inline void BinlogEvent::set_table(const char* value, size_t size) {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  table_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BinlogEvent::mutable_table() {
  set_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    table_ = new ::std::string;
  }
  return table_;
}
inline ::std::string* BinlogEvent::release_table() {
  clear_has_table();
  if (table_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = table_;
    table_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .binlog_listener.EventType event_type = 3;
inline bool BinlogEvent::has_event_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BinlogEvent::set_has_event_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BinlogEvent::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BinlogEvent::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline binlog_listener::EventType BinlogEvent::event_type() const {
  return static_cast< binlog_listener::EventType >(event_type_);
}
inline void BinlogEvent::set_event_type(binlog_listener::EventType value) {
  GOOGLE_DCHECK(binlog_listener::EventType_IsValid(value));
  set_has_event_type();
  event_type_ = value;
}

// optional .binlog_listener.MysubStatus mysub_status = 4;
inline bool BinlogEvent::has_mysub_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BinlogEvent::set_has_mysub_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BinlogEvent::clear_has_mysub_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BinlogEvent::clear_mysub_status() {
  if (mysub_status_ != NULL) mysub_status_->::binlog_listener::MysubStatus::Clear();
  clear_has_mysub_status();
}
inline const ::binlog_listener::MysubStatus& BinlogEvent::mysub_status() const {
  return mysub_status_ != NULL ? *mysub_status_ : *default_instance_->mysub_status_;
}
inline ::binlog_listener::MysubStatus* BinlogEvent::mutable_mysub_status() {
  set_has_mysub_status();
  if (mysub_status_ == NULL) mysub_status_ = new ::binlog_listener::MysubStatus;
  return mysub_status_;
}
inline ::binlog_listener::MysubStatus* BinlogEvent::release_mysub_status() {
  clear_has_mysub_status();
  ::binlog_listener::MysubStatus* temp = mysub_status_;
  mysub_status_ = NULL;
  return temp;
}

// optional string charset = 5;
inline bool BinlogEvent::has_charset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BinlogEvent::set_has_charset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BinlogEvent::clear_has_charset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BinlogEvent::clear_charset() {
  if (charset_ != &::google::protobuf::internal::kEmptyString) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& BinlogEvent::charset() const {
  return *charset_;
}
inline void BinlogEvent::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void BinlogEvent::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
}
inline void BinlogEvent::set_charset(const char* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BinlogEvent::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    charset_ = new ::std::string;
  }
  return charset_;
}
inline ::std::string* BinlogEvent::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .binlog_listener.Row row = 6;
inline bool BinlogEvent::has_row() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BinlogEvent::set_has_row() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BinlogEvent::clear_has_row() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BinlogEvent::clear_row() {
  if (row_ != NULL) row_->::binlog_listener::Row::Clear();
  clear_has_row();
}
inline const ::binlog_listener::Row& BinlogEvent::row() const {
  return row_ != NULL ? *row_ : *default_instance_->row_;
}
inline ::binlog_listener::Row* BinlogEvent::mutable_row() {
  set_has_row();
  if (row_ == NULL) row_ = new ::binlog_listener::Row;
  return row_;
}
inline ::binlog_listener::Row* BinlogEvent::release_row() {
  clear_has_row();
  ::binlog_listener::Row* temp = row_;
  row_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace binlog_listener

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< binlog_listener::MysqlType>() {
  return binlog_listener::MysqlType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< binlog_listener::EventType>() {
  return binlog_listener::EventType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_binlog_5fevent_2eproto__INCLUDED
